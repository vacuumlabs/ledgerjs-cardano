{"version":3,"sources":["../src/Ada.js"],"names":["CLA","INS","GET_VERSION","GET_EXT_PUBLIC_KEY","DERIVE_ADDRESS","ATTEST_UTXO","SIGN_TX","RUN_TESTS","ErrorCodes","ERR_STILL_IN_CALL","ERR_INVALID_DATA","ERR_INVALID_BIP_PATH","ERR_REJECTED_BY_USER","ERR_REJECTED_BY_POLICY","ERR_CLA_NOT_SUPPORTED","GH_ERRORS_LINK","ErrorMsgs","getErrorDescription","statusCode","statusCodeHex","toString","defaultMsg","wrapRetryStillInCall","fn","wrapConvertError","message","Ada","transport","scrambleKey","methods","decorateAppAPIMethods","send","_send","p1","p2","data","then","utils","stripRetcodeFromResponse","P1_UNUSED","P2_UNUSED","hex_to_buf","response","Assert","assert","length","major","minor","patch","flags_value","FLAG_IS_DEBUG","flags","isDebug","txDataHex","outputIndex","Precondition","checkIsHexString","checkIsUint32","P1_INIT","P1_CONTINUE","CHUNK_SIZE","uint32_to_buf","result","txData","i","chunk","slice","sum","arr","reduce","x","y","sizes","chunkBy","txHash","outputNumber","amount","hmac","rawBuffer","txHashHex","buf_to_hex","buf_to_uint32","amountStr","buf_to_amount","hmacHex","_attestUtxo","path","checkIsValidPath","path_to_buf","publicKey","chainCode","rest","publicKeyHex","chainCodeHex","P1_RETURN","address58","base58_encode","P1_DISPLAY","inputs","outputs","P1_STAGE_INIT","P1_STAGE_INPUTS","P1_STAGE_OUTPUTS","P1_STAGE_CONFIRM","P1_STAGE_WITNESSES","SIGN_TX_INPUT_TYPE_ATTESTED_UTXO","signTx_init","numInputs","numOutputs","Buffer","concat","signTx_addInput","attestation","uint8_to_buf","signTx_addAddressOutput","amount_to_buf","base58_decode","signTx_addChangeOutput","signTx_awaitConfirm","signTx_getWitness","witnessSignatureHex","attestedInputs","push","output","Error","witnesses","input","witness"],"mappings":"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","file":"Ada.js","sourcesContent":["/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// @flow\n\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport { TransportStatusError } from \"@ledgerhq/hw-transport\";\n\nimport utils, { Precondition, Assert } from \"./utils\";\n\nconst CLA = 0xd7;\n\nconst INS = {\n  GET_VERSION: 0x00,\n\n  GET_EXT_PUBLIC_KEY: 0x10,\n  DERIVE_ADDRESS: 0x11,\n\n  ATTEST_UTXO: 0x20,\n  SIGN_TX: 0x21,\n\n  RUN_TESTS: 0xf0\n};\n\nexport type BIP32Path = Array<number>;\n\nexport type InputTypeUTxO = {|\n  txDataHex: string,\n  outputIndex: number,\n  path: BIP32Path\n|};\n\nexport type OutputTypeAddress = {|\n  amountStr: string,\n  address58: string\n|};\n\nexport type OutputTypeChange = {|\n  amountStr: string,\n  path: BIP32Path\n|};\n\nexport type Flags = {|\n  isDebug: boolean\n|};\n\nexport type GetVersionResponse = {|\n  major: string,\n  minor: string,\n  patch: string,\n  flags: Flags\n|};\n\nexport type DeriveAddressResponse = {|\n  address58: string\n|};\n\nexport type GetExtendedPublicKeyResponse = {|\n  publicKeyHex: string,\n  chainCodeHex: string\n|};\n\nexport type Witness = {|\n  path: BIP32Path,\n  // Note: this is *only* a signature\n  // you need to add proper extended public key\n  // to form a full witness\n  witnessSignatureHex: string\n|};\n\nexport type SignTransactionResponse = {|\n  txHashHex: string,\n  witnesses: Array<Witness>\n|};\n\nexport const ErrorCodes = {\n  ERR_STILL_IN_CALL: 0x6e04, // internal\n  ERR_INVALID_DATA: 0x6e07,\n  ERR_INVALID_BIP_PATH: 0x6e08,\n  ERR_REJECTED_BY_USER: 0x6e09,\n  ERR_REJECTED_BY_POLICY: 0x6e10,\n\n  // Not thrown by ledger-app-cardano itself but other apps\n  ERR_CLA_NOT_SUPPORTED: 0x6e00\n};\n\nconst GH_ERRORS_LINK =\n  \"https://github.com/cardano-foundation/ledger-app-cardano/blob/master/src/errors.h\";\n\nconst ErrorMsgs = {\n  [ErrorCodes.ERR_INVALID_DATA]: \"Invalid data supplied to Ledger\",\n  [ErrorCodes.ERR_INVALID_BIP_PATH]:\n    \"Invalid derivation path supplied to Ledger\",\n  [ErrorCodes.ERR_REJECTED_BY_USER]: \"Action rejected by user\",\n  [ErrorCodes.ERR_REJECTED_BY_POLICY]:\n    \"Action rejected by Ledger's security policy\",\n  [ErrorCodes.ERR_CLA_NOT_SUPPORTED]: \"Wrong Ledger app\"\n};\n\nexport const getErrorDescription = (statusCode: number) => {\n  const statusCodeHex = `0x${statusCode.toString(16)}`;\n  const defaultMsg = `General error ${statusCodeHex}. Please consult ${GH_ERRORS_LINK}`;\n\n  return ErrorMsgs[statusCode] || defaultMsg;\n};\n\n// It can happen that we try to send a message to the device\n// when the device thinks it is still in a middle of previous ADPU stream.\n// This happens mostly if host does abort communication for some reason\n// leaving ledger mid-call.\n// In this case Ledger will respond by ERR_STILL_IN_CALL *and* resetting its state to\n// default. We can therefore transparently retry the request.\n// Note though that only the *first* request in an multi-APDU exchange should be retried.\nconst wrapRetryStillInCall = fn => async (...args: any) => {\n  try {\n    return await fn(...args);\n  } catch (e) {\n    if (e && e.statusCode && e.statusCode === ErrorCodes.ERR_STILL_IN_CALL) {\n      // Do the retry\n      return await fn(...args);\n    }\n    throw e;\n  }\n};\n\nconst wrapConvertError = fn => async (...args) => {\n  try {\n    return await fn(...args);\n  } catch (e) {\n    if (e && e.statusCode) {\n      // keep HwTransport.TransportStatusError\n      // just override the message\n      e.message = `Ledger device: ${getErrorDescription(e.statusCode)}`;\n    }\n    throw e;\n  }\n};\n/**\n * Cardano ADA API\n *\n * @example\n * import Ada from \"@ledgerhq/hw-app-ada\";\n * const ada = new Ada(transport);\n */\n\ntype SendFn = (number, number, number, number, Buffer) => Promise<Buffer>;\n\nexport default class Ada {\n  transport: Transport<*>;\n  methods: Array<string>;\n  send: SendFn;\n\n  constructor(transport: Transport<*>, scrambleKey: string = \"ADA\") {\n    this.transport = transport;\n    this.methods = [\n      \"getVersion\",\n      \"getExtendedPublicKey\",\n      \"signTransaction\",\n      \"deriveAddress\"\n    ];\n    this.transport.decorateAppAPIMethods(this, this.methods, scrambleKey);\n    this.send = wrapConvertError(this.transport.send);\n  }\n\n  /**\n   * Returns an object containing the app version.\n   *\n   * @returns {Promise<GetVersionResponse>} Result object containing the application version number.\n   *\n   * @example\n   * const { major, minor, patch, flags } = await ada.getVersion();\n   * console.log(`App version ${major}.${minor}.${patch}`);\n   *\n   */\n  async getVersion(): Promise<GetVersionResponse> {\n    const _send = (p1, p2, data) =>\n      this.send(CLA, INS.GET_VERSION, p1, p2, data).then(\n        utils.stripRetcodeFromResponse\n      );\n    const P1_UNUSED = 0x00;\n    const P2_UNUSED = 0x00;\n    const response = await wrapRetryStillInCall(_send)(\n      P1_UNUSED,\n      P2_UNUSED,\n      utils.hex_to_buf(\"\")\n    );\n    Assert.assert(response.length == 4);\n    const [major, minor, patch, flags_value] = response;\n\n    const FLAG_IS_DEBUG = 1;\n    //const FLAG_IS_HEADLESS = 2;\n\n    const flags = {\n      isDebug: (flags_value & FLAG_IS_DEBUG) == FLAG_IS_DEBUG\n    };\n    return { major, minor, patch, flags };\n  }\n\n  /**\n   * Runs unit tests on the device (DEVEL app build only)\n   *\n   * @returns {Promise<void>}\n   */\n  async runTests(): Promise<void> {\n    await wrapRetryStillInCall(this.send)(CLA, INS.RUN_TESTS, 0x00, 0x00);\n  }\n\n  async _attestUtxo(\n    txDataHex: string,\n    outputIndex: number\n  ): Promise<{\n    txHashHex: string,\n    outputIndex: number,\n    amountStr: string,\n    hmacHex: string,\n    rawBuffer: Buffer\n  }> {\n    Precondition.checkIsHexString(txDataHex);\n    Precondition.checkIsUint32(outputIndex);\n\n    const _send = (p1, p2, data) =>\n      this.send(CLA, INS.ATTEST_UTXO, p1, p2, data).then(\n        utils.stripRetcodeFromResponse\n      );\n\n    const P1_INIT = 0x01;\n    const P1_CONTINUE = 0x02;\n\n    const P2_UNUSED = 0x00;\n\n    const CHUNK_SIZE = 255;\n\n    {\n      // Initial request\n      const data = utils.uint32_to_buf(outputIndex);\n      const result = await wrapRetryStillInCall(_send)(\n        P1_INIT,\n        P2_UNUSED,\n        data\n      );\n      Assert.assert(result.length == 0);\n    }\n\n    const txData = utils.hex_to_buf(txDataHex);\n\n    let i = 0;\n    {\n      // middle requests\n      while (i + CHUNK_SIZE < txData.length) {\n        const chunk = txData.slice(i, i + CHUNK_SIZE);\n        const result = await _send(P1_CONTINUE, P2_UNUSED, chunk);\n        Assert.assert(result.length == 0);\n        i += CHUNK_SIZE;\n      }\n    }\n\n    // final request\n    {\n      const chunk = txData.slice(i);\n      const result = await _send(P1_CONTINUE, P2_UNUSED, chunk);\n\n      const sum = arr => arr.reduce((x, y) => x + y, 0);\n\n      const sizes = [32, 4, 8, 16];\n      Assert.assert(result.length == sum(sizes));\n\n      const [txHash, outputNumber, amount, hmac] = utils.chunkBy(result, sizes);\n\n      return {\n        rawBuffer: result,\n        txHashHex: utils.buf_to_hex(txHash),\n        outputIndex: utils.buf_to_uint32(outputNumber),\n        amountStr: utils.buf_to_amount(amount),\n        hmacHex: utils.buf_to_hex(hmac)\n      };\n    }\n  }\n\n  /**\n   * @param string Raw transaction data (without witnesses) encoded as hex string\n   * @param number Output indes\n   *\n   */\n  async attestUtxo(\n    txDataHex: string,\n    outputIndex: number\n  ): Promise<{\n    txHashHex: string,\n    outputIndex: number,\n    amountStr: string,\n    hmacHex: string,\n    rawBuffer: Buffer\n  }> {\n    return this._attestUtxo(txDataHex, outputIndex);\n  }\n\n  /**\n   * @description Get a public key from the specified BIP 32 path.\n   *\n   * @param {BIP32Path} indexes The path indexes. Path must begin with `44'/1815'/n'`, and may be up to 10 indexes long.\n   * @return {Promise<GetExtendedPublicKeyResponse>} The public key with chaincode for the given path.\n   *\n   * @example\n   * const { publicKey, chainCode } = await ada.getExtendedPublicKey([ HARDENED + 44, HARDENED + 1815, HARDENED + 1 ]);\n   * console.log(publicKey);\n   *\n   */\n  async getExtendedPublicKey(\n    path: BIP32Path\n  ): Promise<GetExtendedPublicKeyResponse> {\n    Precondition.checkIsValidPath(path);\n\n    const _send = (p1, p2, data) =>\n      this.send(CLA, INS.GET_EXT_PUBLIC_KEY, p1, p2, data).then(\n        utils.stripRetcodeFromResponse\n      );\n\n    const P1_UNUSED = 0x00;\n    const P2_UNUSED = 0x00;\n\n    const data = utils.path_to_buf(path);\n\n    const response = await wrapRetryStillInCall(_send)(\n      P1_UNUSED,\n      P2_UNUSED,\n      data\n    );\n\n    const [publicKey, chainCode, rest] = utils.chunkBy(response, [32, 32]);\n    Assert.assert(rest.length == 0);\n\n    return {\n      publicKeyHex: publicKey.toString(\"hex\"),\n      chainCodeHex: chainCode.toString(\"hex\")\n    };\n  }\n\n  /**\n   * @description Gets an address from the specified BIP 32 path.\n   *\n   * @param {BIP32Path} indexes The path indexes. Path must begin with `44'/1815'/i'/(0 or 1)/j`, and may be up to 10 indexes long.\n   * @return {Promise<DeriveAddressResponse>} The address for the given path.\n   *\n   * @throws 5001 - The path provided does not have the first 3 indexes hardened or 4th index is not 0 or 1\n   * @throws 5002 - The path provided is less than 5 indexes\n   * @throws 5003 - Some of the indexes is not a number\n   *\n   * @example\n   * const { address } = await ada.deriveAddress([ HARDENED + 44, HARDENED + 1815, HARDENED + 1, 0, 5 ]);\n   *\n   */\n  async deriveAddress(path: BIP32Path): Promise<DeriveAddressResponse> {\n    Precondition.checkIsValidPath(path);\n\n    const _send = (p1, p2, data) =>\n      this.send(CLA, INS.DERIVE_ADDRESS, p1, p2, data).then(\n        utils.stripRetcodeFromResponse\n      );\n\n    const P1_RETURN = 0x01;\n    const P2_UNUSED = 0x00;\n    const data = utils.path_to_buf(path);\n    const response = await _send(P1_RETURN, P2_UNUSED, data);\n\n    return {\n      address58: utils.base58_encode(response)\n    };\n  }\n\n  async showAddress(path: BIP32Path): Promise<void> {\n    Precondition.checkIsValidPath(path);\n\n    const _send = (p1, p2, data) =>\n      this.send(CLA, INS.DERIVE_ADDRESS, p1, p2, data).then(\n        utils.stripRetcodeFromResponse\n      );\n\n    const P1_DISPLAY = 0x02;\n    const P2_UNUSED = 0x00;\n    const data = utils.path_to_buf(path);\n    const response = await _send(P1_DISPLAY, P2_UNUSED, data);\n    Assert.assert(response.length == 0);\n  }\n\n  async signTransaction(\n    inputs: Array<InputTypeUTxO>,\n    outputs: Array<OutputTypeAddress | OutputTypeChange>\n  ): Promise<SignTransactionResponse> {\n    //console.log(\"sign\");\n\n    const P1_STAGE_INIT = 0x01;\n    const P1_STAGE_INPUTS = 0x02;\n    const P1_STAGE_OUTPUTS = 0x03;\n    const P1_STAGE_CONFIRM = 0x04;\n    const P1_STAGE_WITNESSES = 0x05;\n    const P2_UNUSED = 0x00;\n    const SIGN_TX_INPUT_TYPE_ATTESTED_UTXO = 0x01;\n\n    const _send = (p1, p2, data) =>\n      this.send(CLA, INS.SIGN_TX, p1, p2, data).then(\n        utils.stripRetcodeFromResponse\n      );\n\n    const signTx_init = async (\n      numInputs: number,\n      numOutputs: number\n    ): Promise<void> => {\n      const data = Buffer.concat([\n        utils.uint32_to_buf(numInputs),\n        utils.uint32_to_buf(numOutputs)\n      ]);\n      const response = await wrapRetryStillInCall(_send)(\n        P1_STAGE_INIT,\n        P2_UNUSED,\n        data\n      );\n      Assert.assert(response.length == 0);\n    };\n\n    const signTx_addInput = async (attestation): Promise<void> => {\n      const data = Buffer.concat([\n        utils.uint8_to_buf(SIGN_TX_INPUT_TYPE_ATTESTED_UTXO),\n        attestation.rawBuffer\n      ]);\n      const response = await _send(P1_STAGE_INPUTS, P2_UNUSED, data);\n      Assert.assert(response.length == 0);\n    };\n\n    const signTx_addAddressOutput = async (\n      address58: string,\n      amountStr: string\n    ): Promise<void> => {\n      const data = Buffer.concat([\n        utils.amount_to_buf(amountStr),\n        utils.uint8_to_buf(0x01),\n        utils.base58_decode(address58)\n      ]);\n      const response = await _send(P1_STAGE_OUTPUTS, P2_UNUSED, data);\n      Assert.assert(response.length == 0);\n    };\n\n    const signTx_addChangeOutput = async (\n      path: BIP32Path,\n      amountStr: string\n    ): Promise<void> => {\n      const data = Buffer.concat([\n        utils.amount_to_buf(amountStr),\n        utils.uint8_to_buf(0x02),\n        utils.path_to_buf(path)\n      ]);\n      const response = await _send(P1_STAGE_OUTPUTS, P2_UNUSED, data);\n      Assert.assert(response.length == 0);\n    };\n\n    const signTx_awaitConfirm = async (): Promise<{\n      txHashHex: string\n    }> => {\n      const response = await _send(\n        P1_STAGE_CONFIRM,\n        P2_UNUSED,\n        utils.hex_to_buf(\"\")\n      );\n      return {\n        txHashHex: response.toString(\"hex\")\n      };\n    };\n\n    const signTx_getWitness = async (\n      path: BIP32Path\n    ): Promise<{|\n      path: BIP32Path,\n      witnessSignatureHex: string\n    |}> => {\n      const data = Buffer.concat([utils.path_to_buf(path)]);\n      const response = await _send(P1_STAGE_WITNESSES, P2_UNUSED, data);\n      return {\n        path: path,\n        witnessSignatureHex: utils.buf_to_hex(response)\n      };\n    };\n\n    //console.log(\"attest\");\n    const attestedInputs = [];\n    // attest\n    for (const { txDataHex, outputIndex } of inputs) {\n      const attestation = await this._attestUtxo(txDataHex, outputIndex);\n      attestedInputs.push(attestation);\n    }\n\n    // init\n    //console.log(\"init\");\n    await signTx_init(attestedInputs.length, outputs.length);\n\n    // inputs\n    //console.log(\"inputs\");\n    for (const attestation of attestedInputs) {\n      await signTx_addInput(attestation);\n    }\n\n    // outputs\n    //console.log(\"outputs\");\n    for (const output of outputs) {\n      if (output.address58) {\n        await signTx_addAddressOutput(output.address58, output.amountStr);\n      } else if (output.path) {\n        await signTx_addChangeOutput(output.path, output.amountStr);\n      } else {\n        throw new Error(\"TODO\");\n      }\n    }\n\n    // confirm\n    //console.log(\"confirm\");\n    const { txHashHex } = await signTx_awaitConfirm();\n\n    //console.log(\"witnesses\");\n    const witnesses = [];\n    for (const input of inputs) {\n      const witness = await signTx_getWitness(input.path);\n      witnesses.push(witness);\n    }\n    return {\n      txHashHex,\n      witnesses\n    };\n  }\n}\n\nexport {\n  utils // reexport\n};\n"]}