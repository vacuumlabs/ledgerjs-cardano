{"version":3,"sources":["../src/Ada.js"],"names":["CLA","INS","GET_VERSION","GET_EXT_PUBLIC_KEY","DERIVE_ADDRESS","ATTEST_UTXO","SIGN_TX","RUN_TESTS","Ada","transport","scrambleKey","methods","decorateAppAPIMethods","_send","p1","p2","data","send","then","stripRetcodeFromResponse","P1_UNUSED","P2_UNUSED","hex_to_buf","response","assert","length","major","minor","patch","flags_value","FLAG_IS_DEBUG","flags","isDebug","txDataHex","outputIndex","checkIsHexString","checkIsUint32","P1_INIT","P1_CONTINUE","CHUNK_SIZE","uint32_to_buf","result","txData","i","chunk","slice","sum","arr","reduce","x","y","sizes","chunkBy","txHash","outputNumber","amount","hmac","rawBuffer","txHashHex","buf_to_hex","buf_to_uint32","amountStr","buf_to_amount","hmacHex","_attestUtxo","path","checkIsValidPath","path_to_buf","publicKey","chainCode","rest","publicKeyHex","toString","chainCodeHex","P1_RETURN","address58","base58_encode","P1_DISPLAY","inputs","outputs","P1_STAGE_INIT","P1_STAGE_INPUTS","P1_STAGE_OUTPUTS","P1_STAGE_CONFIRM","P1_STAGE_WITNESSES","SIGN_TX_INPUT_TYPE_ATTESTED_UTXO","signTx_init","numInputs","numOutputs","Buffer","concat","signTx_addInput","attestation","uint8_to_buf","signTx_addAddressOutput","amount_to_buf","base58_decode","signTx_addChangeOutput","signTx_awaitConfirm","signTx_getWitness","witnessHex","attestedInputs","push","output","Error","witnesses","input","witness","utils"],"mappings":"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","file":"Ada.js","sourcesContent":["/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// @flow\n\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport { TransportStatusError } from \"@ledgerhq/hw-transport\";\n\nimport utils, { Precondition, Assert } from \"./utils\";\n\nconst CLA = 0xd7;\n\nconst INS = {\n  GET_VERSION: 0x00,\n\n  GET_EXT_PUBLIC_KEY: 0x10,\n  DERIVE_ADDRESS: 0x11,\n\n  ATTEST_UTXO: 0x20,\n  SIGN_TX: 0x21,\n\n  RUN_TESTS: 0xf0\n};\n\nexport type BIP32Path = Array<number>;\n\nexport type InputTypeUTxO = {|\n  txDataHex: string,\n  outputIndex: number,\n  path: BIP32Path\n|};\n\nexport type OutputTypeAddress = {|\n  amountStr: string,\n  address58: string\n|};\n\nexport type OutputTypeChange = {|\n  amountStr: string,\n  path: BIP32Path\n|};\n\n/**\n * Cardano ADA API\n *\n * @example\n * import Ada from \"@ledgerhq/hw-app-ada\";\n * const ada = new Ada(transport);\n */\nexport default class Ada {\n  transport: Transport<*>;\n  methods: Array<string>;\n\n  constructor(transport: Transport<*>, scrambleKey: string = \"ADA\") {\n    this.transport = transport;\n    this.methods = [\n      \"getVersion\",\n      \"getExtendedPublicKey\",\n      \"signTransaction\",\n      \"deriveAddress\"\n    ];\n    this.transport.decorateAppAPIMethods(this, this.methods, scrambleKey);\n  }\n\n  /**\n   * Returns an object containing the app version.\n   *\n   * @returns {Promise<{major:number, minor:number, patch:number}>} Result object containing the application version number.\n   *\n   * @example\n   * const { major, minor, patch, flags } = await ada.getVersion();\n   * console.log(`App version ${major}.${minor}.${patch}`);\n   *\n   */\n  async getVersion(): Promise<{\n    major: string,\n    minor: string,\n    patch: string\n  }> {\n    const _send = (p1, p2, data) =>\n      this.transport\n        .send(CLA, INS.GET_VERSION, p1, p2, data)\n        .then(utils.stripRetcodeFromResponse);\n\n    const P1_UNUSED = 0x00;\n    const P2_UNUSED = 0x00;\n    const response = await _send(P1_UNUSED, P2_UNUSED, utils.hex_to_buf(\"\"));\n    Assert.assert(response.length == 4);\n    const [major, minor, patch, flags_value] = response;\n\n    const FLAG_IS_DEBUG = 1;\n    //const FLAG_IS_HEADLESS = 2;\n\n    const flags = {\n      isDebug: (flags_value & FLAG_IS_DEBUG) == FLAG_IS_DEBUG\n    };\n    return { major, minor, patch, flags };\n  }\n\n  /**\n   * Runs unit tests on the device (DEVEL app build only)\n   *\n   * @returns {Promise<void>}\n   */\n  async runTests(): Promise<void> {\n    await this.transport.send(CLA, INS.RUN_TESTS, 0x00, 0x00);\n  }\n\n  async _attestUtxo(\n    txDataHex: string,\n    outputIndex: number\n  ): Promise<{\n    txHashHex: string,\n    outputIndex: number,\n    amountStr: string,\n    hmacHex: string,\n    rawBuffer: Buffer\n  }> {\n    Precondition.checkIsHexString(txDataHex);\n    Precondition.checkIsUint32(outputIndex);\n\n    const _send = (p1, p2, data) =>\n      this.transport\n        .send(CLA, INS.ATTEST_UTXO, p1, p2, data)\n        .then(utils.stripRetcodeFromResponse);\n\n    const P1_INIT = 0x01;\n    const P1_CONTINUE = 0x02;\n\n    const P2_UNUSED = 0x00;\n\n    /*\n    * it's 250 because 5 more bytes are appended\n    * by hw-transport-u2f and u2f has a limit of 255 bytes\n    */\n    const CHUNK_SIZE = 250;\n\n    {\n      // Initial request\n      const data = utils.uint32_to_buf(outputIndex);\n      const result = await _send(P1_INIT, P2_UNUSED, data);\n      Assert.assert(result.length == 0);\n    }\n\n    const txData = utils.hex_to_buf(txDataHex);\n\n    let i = 0;\n    {\n      // middle requests\n      while (i + CHUNK_SIZE < txData.length) {\n        const chunk = txData.slice(i, i + CHUNK_SIZE);\n        const result = await _send(P1_CONTINUE, P2_UNUSED, chunk);\n        Assert.assert(result.length == 0);\n        i += CHUNK_SIZE;\n      }\n    }\n\n    // final request\n    {\n      const chunk = txData.slice(i);\n      const result = await _send(P1_CONTINUE, P2_UNUSED, chunk);\n\n      const sum = arr => arr.reduce((x, y) => x + y, 0);\n\n      const sizes = [32, 4, 8, 16];\n      Assert.assert(result.length == sum(sizes));\n\n      const [txHash, outputNumber, amount, hmac] = utils.chunkBy(result, sizes);\n\n      return {\n        rawBuffer: result,\n        txHashHex: utils.buf_to_hex(txHash),\n        outputIndex: utils.buf_to_uint32(outputNumber),\n        amountStr: utils.buf_to_amount(amount),\n        hmacHex: utils.buf_to_hex(hmac)\n      };\n    }\n  }\n\n  /**\n   * @param string Raw transaction data (without witnesses) encoded as hex string\n   * @param number Output indes\n   *\n   */\n  async attestUtxo(\n    txDataHex: string,\n    outputIndex: number\n  ): Promise<{\n    txHashHex: string,\n    outputIndex: number,\n    amountStr: string,\n    hmacHex: string,\n    rawBuffer: Buffer\n  }> {\n    return this._attestUtxo(txDataHex, outputIndex);\n  }\n\n  /**\n   * @description Get a public key from the specified BIP 32 path.\n   *\n   * @param {Array<number>} indexes The path indexes. Path must begin with `44'/1815'/n'`, and may be up to 10 indexes long.\n   * @return {Promise<{ publicKey:string, chainCode:string }>} The public key with chaincode for the given path.\n   *\n   * @example\n   * const { publicKey, chainCode } = await ada.getExtendedPublicKey([ HARDENED + 44, HARDENED + 1815, HARDENED + 1 ]);\n   * console.log(publicKey);\n   *\n   */\n  async getExtendedPublicKey(\n    path: BIP32Path\n  ): Promise<{ publicKeyHex: string, chainCodeHex: string }> {\n    Precondition.checkIsValidPath(path);\n\n    const _send = (p1, p2, data) =>\n      this.transport\n        .send(CLA, INS.GET_EXT_PUBLIC_KEY, p1, p2, data)\n        .then(utils.stripRetcodeFromResponse);\n\n    const P1_UNUSED = 0x00;\n    const P2_UNUSED = 0x00;\n\n    const data = utils.path_to_buf(path);\n\n    const response = await _send(P1_UNUSED, P2_UNUSED, data);\n\n    const [publicKey, chainCode, rest] = utils.chunkBy(response, [32, 32]);\n    Assert.assert(rest.length == 0);\n\n    return {\n      publicKeyHex: publicKey.toString(\"hex\"),\n      chainCodeHex: chainCode.toString(\"hex\")\n    };\n  }\n\n  /**\n   * @description Gets an address from the specified BIP 32 path.\n   *\n   * @param {Array<number>} indexes The path indexes. Path must begin with `44'/1815'/i'/(0 or 1)/j`, and may be up to 10 indexes long.\n   * @return {Promise<{ address:string }>} The address for the given path.\n   *\n   * @throws 5001 - The path provided does not have the first 3 indexes hardened or 4th index is not 0 or 1\n   * @throws 5002 - The path provided is less than 5 indexes\n   * @throws 5003 - Some of the indexes is not a number\n   *\n   * @example\n   * const { address } = await ada.deriveAddress([ HARDENED + 44, HARDENED + 1815, HARDENED + 1, 0, 5 ]);\n   *\n   */\n  async deriveAddress(path: BIP32Path): Promise<{ address58: string }> {\n    Precondition.checkIsValidPath(path);\n\n    const _send = (p1, p2, data) =>\n      this.transport\n        .send(CLA, INS.DERIVE_ADDRESS, p1, p2, data)\n        .then(utils.stripRetcodeFromResponse);\n\n    const P1_RETURN = 0x01;\n    const P2_UNUSED = 0x00;\n    const data = utils.path_to_buf(path);\n    const response = await _send(P1_RETURN, P2_UNUSED, data);\n\n    return {\n      address58: utils.base58_encode(response)\n    };\n  }\n\n  async showAddress(path: BIP32Path): Promise<void> {\n    Precondition.checkIsValidPath(path);\n\n    const _send = (p1, p2, data) =>\n      this.transport\n        .send(CLA, INS.DERIVE_ADDRESS, p1, p2, data)\n        .then(utils.stripRetcodeFromResponse);\n\n    const P1_DISPLAY = 0x02;\n    const P2_UNUSED = 0x00;\n    const data = utils.path_to_buf(path);\n    const response = await _send(P1_DISPLAY, P2_UNUSED, data);\n    Assert.assert(response.length == 0);\n  }\n\n  async signTransaction(\n    inputs: Array<InputTypeUTxO>,\n    outputs: Array<OutputTypeAddress | OutputTypeChange>\n  ) {\n    //console.log(\"sign\");\n\n    const P1_STAGE_INIT = 0x01;\n    const P1_STAGE_INPUTS = 0x02;\n    const P1_STAGE_OUTPUTS = 0x03;\n    const P1_STAGE_CONFIRM = 0x04;\n    const P1_STAGE_WITNESSES = 0x05;\n    const P2_UNUSED = 0x00;\n    const SIGN_TX_INPUT_TYPE_ATTESTED_UTXO = 0x01;\n\n    const _send = (p1, p2, data) =>\n      this.transport\n        .send(CLA, INS.SIGN_TX, p1, p2, data)\n        .then(utils.stripRetcodeFromResponse);\n\n    const signTx_init = async (\n      numInputs: number,\n      numOutputs: number\n    ): Promise<void> => {\n      const data = Buffer.concat([\n        utils.uint32_to_buf(numInputs),\n        utils.uint32_to_buf(numOutputs)\n      ]);\n      const response = await _send(P1_STAGE_INIT, P2_UNUSED, data);\n      Assert.assert(response.length == 0);\n    };\n\n    const signTx_addInput = async (attestation): Promise<void> => {\n      const data = Buffer.concat([\n        utils.uint8_to_buf(SIGN_TX_INPUT_TYPE_ATTESTED_UTXO),\n        attestation.rawBuffer\n      ]);\n      const response = await _send(P1_STAGE_INPUTS, P2_UNUSED, data);\n      Assert.assert(response.length == 0);\n    };\n\n    const signTx_addAddressOutput = async (\n      address58: string,\n      amountStr: string\n    ): Promise<void> => {\n      const data = Buffer.concat([\n        utils.amount_to_buf(amountStr),\n        utils.uint8_to_buf(0x01),\n        utils.base58_decode(address58)\n      ]);\n      const response = await _send(P1_STAGE_OUTPUTS, P2_UNUSED, data);\n      Assert.assert(response.length == 0);\n    };\n\n    const signTx_addChangeOutput = async (\n      path: BIP32Path,\n      amountStr: string\n    ): Promise<void> => {\n      const data = Buffer.concat([\n        utils.amount_to_buf(amountStr),\n        utils.uint8_to_buf(0x02),\n        utils.path_to_buf(path)\n      ]);\n      const response = await _send(P1_STAGE_OUTPUTS, P2_UNUSED, data);\n      Assert.assert(response.length == 0);\n    };\n\n    const signTx_awaitConfirm = async (): Promise<{\n      txHashHex: string\n    }> => {\n      const response = await _send(\n        P1_STAGE_CONFIRM,\n        P2_UNUSED,\n        utils.hex_to_buf(\"\")\n      );\n      return {\n        txHashHex: response.toString(\"hex\")\n      };\n    };\n\n    const signTx_getWitness = async (\n      path: BIP32Path\n    ): Promise<{\n      path: BIP32Path,\n      witnessHex: string\n    }> => {\n      const data = Buffer.concat([utils.path_to_buf(path)]);\n      const response = await _send(P1_STAGE_WITNESSES, P2_UNUSED, data);\n      return {\n        path: path,\n        witnessHex: utils.buf_to_hex(response)\n      };\n    };\n\n    //console.log(\"attest\");\n    const attestedInputs = [];\n    // attest\n    for (const { txDataHex, outputIndex } of inputs) {\n      const attestation = await this._attestUtxo(txDataHex, outputIndex);\n      attestedInputs.push(attestation);\n    }\n\n    // init\n    //console.log(\"init\");\n    await signTx_init(attestedInputs.length, outputs.length);\n\n    // inputs\n    //console.log(\"inputs\");\n    for (const attestation of attestedInputs) {\n      await signTx_addInput(attestation);\n    }\n\n    // outputs\n    //console.log(\"outputs\");\n    for (const output of outputs) {\n      if (output.address58) {\n        await signTx_addAddressOutput(output.address58, output.amountStr);\n      } else if (output.path) {\n        await signTx_addChangeOutput(output.path, output.amountStr);\n      } else {\n        throw new Error(\"TODO\");\n      }\n    }\n\n    // confirm\n    //console.log(\"confirm\");\n    const { txHashHex } = await signTx_awaitConfirm();\n\n    //console.log(\"witnesses\");\n    const witnesses = [];\n    for (const input of inputs) {\n      const witness = await signTx_getWitness(input.path);\n      witnesses.push(witness);\n    }\n    return {\n      txHashHex,\n      witnesses\n    };\n  }\n}\n\nexport {\n  utils // reexport\n};\n"]}